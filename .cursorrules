# Health Prediction App – Clean Architecture Coding Rules

## Technology Stack

- React Native (Expo Router)
- TypeScript (strict mode, noUncheckedIndexedAccess)
- Clean Architecture (Domain, Data, Presentation layers)
- Dependency Injection Container
- MVVM Pattern with ViewModels
- Yarn package manager (never npm)
- Design System for reusable UI components
- Jest + React Native Testing Library for testing
- ESLint + Prettier + Husky for code linting & formatting pre-commit

## Architecture Overview

### Clean Architecture Layers

```
/src
├── /domain           → Business logic & entities
│   ├── /entities     → Domain models (User, HealthPrediction, etc.)
│   ├── /repositories → Repository interfaces
│   └── /usecases     → Business use cases
├── /data             → Data layer implementation
│   └── /repositories → Repository implementations (API, Local)
├── /presentation     → UI layer
│   ├── /viewmodels   → MVVM ViewModels
│   └── /components   → UI components
└── /core             → Cross-cutting concerns
    └── /di           → Dependency Injection
```

### Layer Dependencies

- **Presentation** → **Domain** (ViewModels use Use Cases)
- **Data** → **Domain** (Repositories implement Domain interfaces)
- **Domain** → **Nothing** (Pure business logic)
- **Core** → **All layers** (DI container)

## Code Standards

### TypeScript

- Strict mode always enabled
- interface for props, state, API responses
- Use type for unions & utility types
- No any / unknown without type guards
- Use generics for reusable hooks & utilities
- Type guards (isXxx) for runtime checks
- Enforce ReturnType and Parameters for selectors & thunks
- Prefer readonly & as const for immutability
- **Domain entities**: Use readonly properties, immutable objects
- **Use cases**: Pure functions, no side effects
- **ViewModels**: State management with React hooks

### Clean Architecture Rules

#### Domain Layer
- **Entities**: Pure business objects with validation logic
- **Use Cases**: Single responsibility, dependency inversion
- **Repositories**: Abstract interfaces, no implementation details
- **No external dependencies**: Only TypeScript types

#### Data Layer
- **Repository implementations**: Concrete implementations of domain interfaces
- **API services**: HTTP client abstraction
- **Data mapping**: Convert API responses to domain entities
- **Error handling**: Transform network errors to domain errors

#### Presentation Layer
- **ViewModels**: Business logic for UI, state management
- **Components**: Pure UI, no business logic
- **MVVM pattern**: View ↔ ViewModel ↔ Use Cases
- **Dependency injection**: Use DI container for dependencies

### React Native

- Functional components only, with hooks
- React.memo + useCallback + useMemo for expensive renders
- ErrorBoundary per navigation stack
- Native driver for animations
- Always wrap screens in SafeAreaView
- KeyboardAvoidingView where user input is required
- **ViewModels**: Use custom hooks for state management
- **Components**: Receive data via props, emit events via callbacks

### File Structure

```
/app              → Screens (Expo Router) - Legacy, migrate to /src/presentation
/src              → Clean Architecture implementation
├── /domain       → Business logic
├── /data         → Data layer
├── /presentation → UI layer
└── /core         → Cross-cutting concerns
/components       → Legacy UI components (migrate to /src/presentation)
/constants        → Colors, Spacing, Typography
/hooks            → Custom reusable hooks
/services         → Legacy API services (migrate to /src/data)
/store/slices     → Legacy Redux slices (migrate to ViewModels)
/utils            → Pure helper functions
/assets           → Images, fonts
```

- Barrel exports (index.ts) in each folder
- Flat folder design — no deep nesting
- **Migration strategy**: Gradually move from legacy to clean architecture

### Naming Conventions

- PascalCase → Components, Interfaces, Classes, Use Cases
- camelCase → Variables, functions, file names, methods
- SCREAMING_SNAKE_CASE → Constants, Service Keys
- Prefix I → Interfaces (e.g., IUserProfile, IAuthRepository)
- Prefix use → Custom hooks (e.g., useAuthViewModel)
- Suffix UseCase → Use case classes (e.g., LoginUseCase)
- Suffix Repository → Repository classes (e.g., AuthRepository)
- Suffix ViewModel → View model hooks (e.g., useAuthViewModel)

### Dependency Injection

- **Service Keys**: Centralized service registration keys
- **Container**: Singleton DI container
- **Service Registry**: Register all dependencies at app startup
- **Interface-based**: Depend on abstractions, not concretions
- **Testability**: Easy mocking for unit tests

### State Management

#### Legacy (Redux Toolkit)
- Redux Toolkit for global state
- RTK Query for all API calls
- Derived data only via selectors
- Loading/error/success states mandatory
- Persist sensitive tokens only via Expo SecureStore
- No inline business logic in components — only hooks or slices

#### New Architecture (ViewModels)
- **ViewModels**: Custom hooks with useState/useCallback
- **State**: Local component state managed by ViewModels
- **Business Logic**: Encapsulated in Use Cases
- **Dependencies**: Injected via DI container
- **Testing**: Easy to mock and test ViewModels
- **Performance**: Optimized with React.memo and useCallback

### API Integration

#### Legacy (Direct API calls)
- Centralized API client (services/api.ts)
- Strongly typed endpoints with IApiResponse<T>
- Retry logic with exponential backoff
- Graceful handling of timeouts
- Never call fetch directly
- Network status awareness (retry when online)

#### New Architecture (Repository Pattern)
- **Repository interfaces**: Abstract data access in Domain layer
- **Repository implementations**: Concrete API implementations in Data layer
- **Use Cases**: Business logic that uses repositories
- **Error handling**: Domain-specific error types
- **Data mapping**: API responses → Domain entities
- **Dependency injection**: Repositories injected into Use Cases

### Security

- Expo SecureStore for sensitive data
- Input sanitization before storage or API calls
- Never log health data (redact logs)
- End-to-end encryption for health records
- JWT refresh token handling
- Strict privacy compliance (HIPAA/GDPR guidelines)
- Auto logout on token expiry

### Performance

- 60fps animations (use react-native-reanimated if needed)
- Virtualized lists (FlatList, SectionList) for >20 items
- Image caching + compression
- Code-splitting: lazy load large components
- Cleanup in useEffect
- Avoid anonymous functions in JSX
- Monitor memory usage & battery drain
- **Skeleton loading**: Each screen/component needs specific skeleton UI instead of generic loading spinners
- **Skeleton reuse**: Create reusable skeleton components for common UI patterns (cards, lists, forms)
- **Skeleton animation**: Use subtle shimmer/pulse animations for better perceived performance
- **ViewModels**: Optimize with useCallback and useMemo
- **Dependency injection**: Singleton pattern for expensive objects
- **Lazy loading**: Register services only when needed

### Accessibility

- Accessibility labels for all interactive elements
- 44x44pt min touch area
- Full VoiceOver/TalkBack support
- Dynamic text scaling (react-native-size-matters)
- WCAG AA contrast ratio
- Haptic feedback for critical actions

### Error Handling

- ErrorBoundary per navigation root
- try/catch for all async calls
- User-friendly error UI (not raw error messages)
- Retry button for network failures
- Log technical errors with Sentry

### Health App Rules

- Validate every health input (range, units, required)
- Unit conversions (cm ↔ ft, kg ↔ lbs, mmHg ↔ kPa)
- Use medical-grade typography (e.g., large, readable numerics)
- Clear data viz (charts, progress bars, risk meters)
- Handle edge cases (zero, negative, outliers)
- Provide safe disclaimers: "AI predictions are not medical advice"
- Auto-delete health data on user request
- Export health data in secure formats only

### Code Quality

- Functions <50 LOC
- Max 3 nested blocks
- Self-documenting names (no data1, value2)
- Remove unused imports & variables
- ESLint + Prettier run on pre-commit
- Use tsdoc for complex functions
- 80%+ unit test coverage for utilities & slices
- **No hardcoded content**: All text, labels, messages must be in centralized content files
- **Content management**: Create separate files for UI text, error messages, and static content
- **i18n ready**: Structure content files to support future internationalization
- **Clean Architecture**: Follow dependency inversion principle
- **Single Responsibility**: Each class/function has one reason to change
- **Interface Segregation**: Small, focused interfaces
- **Dependency Injection**: No hard-coded dependencies
- **Testability**: Easy to unit test all layers

### Git Rules

- Conventional commits (feat:, fix:, chore:, refactor:, test:)
- One feature/fix per commit
- Branch naming:
  - feature/health-check-form
  - fix/login-crash
- Pull requests require at least 1 code review
- CI pipeline runs tests + linting before merge

## Strict "No" Rules

- ❌ No console.log in production (use logger)
- ❌ No TODO/FIXME left in code
- ❌ No commented-out code
- ❌ No hardcoded strings (use i18n)
- ❌ No magic numbers (use constants)
- ❌ No duplicate code (refactor to utils/hooks)
- ❌ No unused types or components
- ❌ No missing error handling
- ❌ No missing accessibility labels
- ❌ No inline styles except quick prototypes
- ❌ No direct API calls in components (use ViewModels)
- ❌ No business logic in components (use Use Cases)
- ❌ No concrete dependencies in Domain layer
- ❌ No ViewModels calling repositories directly (use Use Cases)
- ❌ No hard-coded dependencies (use DI container)
- ❌ No mutable domain entities (use readonly)
- ❌ No side effects in Use Cases (pure functions)
